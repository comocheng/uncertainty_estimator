# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.15.2
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# +
 
"""
https://www.itcp.kit.edu/deutschmann/download/publications-others/2014_HerreraDelgadoKarla_H2COCH4Ni_Drrernat_KIT.pdf
"""
import cantera as ct
import numpy as np
import scipy, shutil
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from matplotlib.pyplot import cm
from matplotlib.ticker import NullFormatter, MaxNLocator, LogLocator
plt.switch_backend('agg')  # needed for saving figures
import os, sys, csv, re, operator, pylab, multiprocessing, threading, itertools
# import rmgpy
# import rmg
import pandas as pd
import pylab
from cycler import cycler
import seaborn as sns
from functools import partial

# +

# unit conversion factors to SI
mm = 0.001
cm = 0.01
ms = mm
minute = 60.0


# +

#######################################################################
# Input Parameters
#######################################################################
# t_in = 700  # K - in the paper, it was ~698.15K at the start of the cat surface and ~373.15 for the gas inlet temp
# t_cat = t_in
length = 70 * mm  # Reactor length - m
diam = 19 * mm  # Reactor diameter - in m,
area = (diam/2.0)**2*np.pi # Reactor cross section area (area of tube) in m^2
porosity = 0.46# Monolith channel porosity
cat_area_per_vol = 3.1e6 # m2/m3, page 148,83
bed_len = 12 * mm # catalyt bed length -m
# M_ni = 58.7 # g/mol
# D_ni = 9.5e-3
# wt_percent = 0.2
# m_ni = 0.015 * wt_percent # g
# site_density = 2.66e-5 # mol/m^2
# cat_area_per_vol = D_ni* m_ni / M_ni / site_density / bed_len / area # equation 2.26
flow_rate = 4  # slpm
flow_rate = flow_rate * .001 / 60  # m^3/s
velocity = flow_rate / area  # m/s

# +

# rvol = area * reactor_len * porosity

# # catalyst area in one reactor
# cat_area = cat_area_per_vol * rvol

# root directory for output files
out_root = os.getcwd()

def setup_ct_solution(path_to_cti):

    # this chemkin file is from the cti generated by rmg
    surf = ct.Interface(path_to_cti, 'surface1')
    gas = surf.adjacent['gas']

    print("This mechanism contains {} gas reactions and {} surface reactions".format(gas.n_reactions, surf.n_reactions))
    print(f"Thread ID from threading{threading.get_ident()}")
    i_n2 = gas.species_index('N2')


    return {'gas':gas, 'surf':surf,"i_n2":i_n2,"n_surf_reactions":surf.n_reactions}


# +

def monolith_simulation(path_to_cti, temp, mol_in, verbose=False, sens=False, therm_sens=False):
    """
    Set up and solve the monolith reactor simulation.
    Verbose prints out values as you go along
    Sens is for sensitivity, in the form [perturbation, reaction #]
    Args:
        path_to_cti: full path to the cti file
        temp (float): The temperature in Kelvin
        mol_in (3-tuple or iterable): the inlet molar ratios of (CH4, O2, He)
        verbose (Boolean): whether to print intermediate results
        sens (False or 2-tuple/list): if not False, then should be a 2-tuple or list [dk, rxn]
                in which dk = relative change (eg. 0.01) and rxn = the index of the surface reaction rate to change
       therm_sens (False or 2-tuple/list): if not False, then should be a 2-tuple or list [dH, spc]
               in which dH = enthalpy change (J/kmol) and spc = the index of the surface species thermo to change
    Returns:
        gas_out, # gas molar flow rate in moles/minute
        surf_out, # surface mole fractions
        gas_names, # gas species names
        surf_names, # surface species names
        dist_array, # distances (in mm)
        T_array # temperatures (in K)
    """
    sols_dict = setup_ct_solution(path_to_cti)
    gas, surf, i_n2, n_surf_reactions= sols_dict['gas'], sols_dict['surf'], sols_dict['i_n2'],sols_dict['n_surf_reactions']
    print(f"Running monolith simulation with CO and H2 concs {mol_in[0], mol_in[1]} on thread {threading.get_ident()}")
    
    if therm_sens:
        change_species_enthalpy(surf, spec=therm_sens[1], dH=therm_sens[0], T=temp)
         
    co, h2, n2 = mol_in
    ratio = co / (2 * h2)

    X = f"CO(6):{co}, H2(5):{h2}, N2:{n2}"
    gas.TPX = temp, ct.one_atm, X  # need to initialize mass flow rate at STP
    mass_flow_rate = velocity *(temp/298) * gas.density * area * porosity # kg/s
    temp_cat = temp
    surf.TP = temp_cat, ct.one_atm
    surf.coverages = 'X(1):1.0'

    TDY = gas.TDY
    cov = surf.coverages
    # create a new reactor
    gas.TDY = TDY
    r = ct.FlowReactor(gas)
    r.area = area
    r.surface_area_to_volume_ratio = cat_area_per_vol * porosity
    r.mass_flow_rate = mass_flow_rate
    r.energy_enabled= True
    rsurf = ct.ReactorSurface(surf, r)
    
    sim = ct.ReactorNet([r])
    sim.rtol = 1e-8
    sim.atol = 1e-16
    
    gas_names = gas.species_names
    surf_names = surf.species_names
    gas_out = []
    surf_out = []
    dist_array = []
    T_array = []
    
    if sens:
        rsurf.kinetics.set_multiplier(1+sens[0], sens[1])
    
    while sim.distance <= bed_len:
        dist = sim.distance * 1e3 # convert to mm
        dist_array.append(dist)
        gas_out.append(r.kinetics.X)
        surf_out.append(rsurf.kinetics.coverages)
        T_array.append(rsurf.kinetics.T)
        sim.step()

    gas_out = np.array(gas_out)
    surf_out = np.array(surf_out)
    data_out = gas_out, surf_out, gas_names, surf_names, dist_array, T_array, i_n2, n_surf_reactions
    # plot_gas(data_out)
    # plot_surf(data_out, path_to_cti)
    print(len(dist_array))
    print(f"Finished monolith simulation for CO and H2 concs {mol_in[0], mol_in[1]} on thread {threading.get_ident()}")
    return data_out


# -

def run_one_simulation(path_to_cti, ratio_in, t_in):
    """
    Start all of the simulations all at once using multiprocessing
    """

    a = monolith_simulation(path_to_cti, t_in, ratio_in)
    gas_out, surf_out, gas_names, surf_names, dist_array, T_array, i_ar, n_surf_reactions = a 
    
    # Save the data to csv File
    tol_path = f'profiles/'
    if not os.path.isdir(tol_path):
        os.makedirs(tol_path)
    data_path = os.path.join(tol_path, f'profile_{t_in}k.csv')
    if os.path.exists(data_path):
        os.remove(data_path)
    df_gas = pd.DataFrame(gas_out, columns=gas_names)
    df_surf = pd.DataFrame(surf_out, columns=surf_names)
    df = pd.concat([df_gas, df_surf], axis=1)
    df.insert(0, 'T(K)', T_array)
    df.insert(0, 'Distance(mm)', dist_array)
    df.to_csv(data_path)


# +

def run_sens_simulation(path_to_cti, ratio_in, t_in, kin_sens=False):
    """
    Start all of the simulations all at once using multiprocessing
    """
    a = monolith_simulation(path_to_cti, t_in, ratio_in, sens=kin_sens)
    gas_out, surf_out, gas_names, surf_names, dist_array, T_array, i_ar, n_surf_reactions = a 
    
    # Save the data to csv File
    tol_path = f'kin_sens/{t_in}/'
    if not os.path.isdir(tol_path):
        os.makedirs(tol_path)
    data_path = os.path.join(tol_path, f'rxn{kin_sens[1]}_sens.csv')
    df_gas = pd.DataFrame(gas_out, columns=gas_names)
    df_surf = pd.DataFrame(surf_out, columns=surf_names)
    df = pd.concat([df_gas, df_surf], axis=1)
    df.insert(0, 'T(K)', T_array)
    df.insert(0, 'Distance(mm)', dist_array)
    df.to_csv(data_path)


# +

def draw_profile(csv_ps):
    """
    :csv_ps: paths to the csv file with species profile data
    """
    cos = []
    ch4s = []
    co2s= []
    h2s = []
    h2os = []
    temps = []
    for p in csv_ps:
        df = pd.read_csv(p)
        sum_mol = df.iloc[0,:][3:19].sum()
        co = df.loc[:,'CO(6)'].to_numpy()[-1] / sum_mol
        ch4 = df.loc[:,'CH4(2)'].to_numpy()[-1] / sum_mol
        co2 = df.loc[:,'CO2(3)'].to_numpy()[-1] / sum_mol
        h2 = df.loc[:,'H2(5)'].to_numpy()[-1] / sum_mol
        h2o = df.loc[:,'H2O(4)'].to_numpy()[-1] / sum_mol
        temp = df.loc[:,'T(K)'].to_numpy()[0]
        cos.append(co)
        ch4s.append(ch4)
        co2s.append(co2)
        h2s.append(h2)
        h2os.append(h2o)
        temps.append(temp)
    plt.plot(temps, cos, label='CO')
    plt.plot(temps, h2s, label='H2')
    plt.legend()
    plt.savefig('figures/profile_temp.png')



# +
yml = '/home/moon/uncertainty_estimator/cpox_pt/cpox_rh_emily/chem_annotated-gas.yaml'
ratio = [0.0204, 0.07, 0.9096]


run_one_simulation(yml, ratio[1], 1000)


# temperatures = list(range(353, 573, 20)) + list(range(573, 653, 10)) + list(range(653, 873, 20))
# data = []
# num_threads = min(multiprocessing.cpu_count(), len(temperatures))
# pool = multiprocessing.Pool(processes=num_threads)
# pool.map(partial(run_one_simulation, yml, ratio), temperatures)
# pool.close()
# pool.join()
# csvs = []
# for t in temperatures:
#     csv_p = f'profiles/profile_{t}k.csv'
#     if os.path.exists(csv_p):
#         csvs.append(csv_p)
# draw_profile(csvs)
# -





# +

if __name__ == "__main__":
    yml = '../no_cov/cantera/chem.yaml'
    ratio = [0.0204, 0.07, 0.9096]
    if sys.argv[1] == 'kinsens':
        temp = float(sys.argv[2])
        n_rxns = setup_ct_solution(yml)['n_surf_reactions']
        num_threads = min(multiprocessing.cpu_count(), n_rxns)
        kin_sens_list = [[0.001, i] for i in range(n_rxns)]
        with multiprocessing.Pool(processes=num_threads) as pool:
            pool.map(partial(run_sens_simulation, yml, ratio, temp), kin_sens_list)
    elif sys.argv[1] == 'thermsens':
        pass
    elif sys.argv[1] == 'run':
        try:
            temperatures = list(range(353, 573, 20)) + list(range(573, 653, 10)) + list(range(653, 873, 20))
            data = []
            num_threads = min(multiprocessing.cpu_count(), len(temperatures))
            pool = multiprocessing.Pool(processes=num_threads)
            pool.map(partial(run_one_simulation, yml, ratio), temperatures)
            pool.close()
            pool.join()
            csvs = []
            for t in temperatures:
                csv_p = f'profiles/profile_{t}k.csv'
                if os.path.exists(csv_p):
                    csvs.append(csv_p)
            draw_profile(csvs)
        except Exception as e:
            print(e)
            csvs = []
            for t in temperatures:
                csv_p = f'profiles/profile_{t}k.csv'
                if os.path.exists(csv_p):
                    csvs.append(csv_p)
            draw_profile(csvs)
    else:
        print('Input parameter should be run, kinsens or thermsens')
# -




