# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.15.2
#   kernelspec:
#     display_name: Python 3 (ipykernel)
#     language: python
#     name: python3
# ---

# # A notebook to demonstrate the different kinetics sources for uncertainty

# +
import os
import re
import rmgpy.chemkin
import rmgpy.data.rmg
import rmgpy.data.kinetics.family

import importlib
importlib.reload(rmgpy.data.kinetics.family)
# -

# pick an annotated chemkin file to analyze
chemkin_file = 'chem_annotated.inp'
dict_file = 'species_dictionary.txt'
species_list, reaction_list = rmgpy.chemkin.load_chemkin_file(chemkin_file, dict_file)

# +
database = rmgpy.data.rmg.RMGDatabase()
thermo_libraries = [
    'primaryThermoLibrary',
    'BurkeH2O2'
]
reaction_libraries = [
    'BurkeH2O2inN2'
]
kinetics_families = [
    'Disproportionation',
    'H_Abstraction',
    'intra_H_migration',
    'R_Recombination',
    'Intra_Disproportionation',
]

database.load(
    path = rmgpy.settings['database.directory'],
    thermo_libraries = thermo_libraries,
    transport_libraries = [],
    reaction_libraries = reaction_libraries,
    seed_mechanisms = [],
    kinetics_families = kinetics_families,
    kinetics_depositories = ['training'],
    depository = False, # Don't bother loading the depository information, as we don't use it
)


for family in database.kinetics.families:
    if not database.kinetics.families[family].auto_generated:
        database.kinetics.families[family].add_rules_from_training(thermo_database=database.thermo)
        database.kinetics.families[family].fill_rules_by_averaging_up(verbose=True)


# +
sources = {}

for i in range(len(reaction_list)):
    if not hasattr(reaction_list[i], 'family'):
        continue
    family = reaction_list[i].family
    src = database.kinetics.families[family].extract_source_from_comments(reaction_list[i])
    sources[i] = src
# -

# This set uses rate rules
for key in sources.keys():
    if not sources[key][0]:
        if sources[key][1][1]['rules']:
            print(key)

# Show an example of the rate rules
reaction_list[85].kinetics.comment



# ### Exact match for training reaction in family

# Exact match for training reaction - show first 5 examples
# for i in range(len(reaction_list)):
for i in range(5):
    if i not in sources.keys():
        continue
    
    src = sources[i]
    exact_training_match = src[0]
    family = src[1][0]
    if exact_training_match:
        print(i, reaction_list[i].kinetics.comment)
        print()


# ### Autogenerated family node

# Print examples of kinetics that match a node in an autogenerated tree
for i in range(25):
    if i not in sources.keys():
        continue
    src = sources[i]
    
    # Skip exact matches for training reactions
    exact_training_match = src[0]
    if exact_training_match:
        continue
    
    family = src[1][0]
    if not database.kinetics.families[family].auto_generated:
        continue
    
    print(i, reaction_list[i].kinetics.comment)
    print()


# ### Hand-built trees: exact match for a family's rate rule

# Exact match for training reaction -- this is how you get 
for i in range(len(reaction_list)):
    if i not in sources.keys():
        continue
    
    src = sources[i]
    exact_training_match = src[0]
    if exact_training_match:
        continue
    exact_rule_match = src[1][1]['exact']
    family = src[1][0]
    if exact_rule_match:
        assert src[1][1]['rules']
        print(i, reaction_list[i].kinetics.comment)
        print()


# ### Combination of rate rules

# #### Estimated using template
#
# This means the combination of groups does not exist as a rule, so we fell up one of the group subtrees to more generic groups until we found a rule that exists
#
# For example, there is no rate rule for [C/H3/Cs\H2\Cs;C_methyl], so you have to fall back to the more generic [C/H3/Cs\OneNonDe;C_methyl] rule, which has data (only because it averaged up the nodes below it).

for i in range(len(reaction_list)):
    if 'Estimated using template' in reaction_list[i].kinetics.comment:
        print(i, reaction_list[i].kinetics.comment)
        family = sources[i][1][0]
        rule_entry_name = ';'.join([template.label for template in sources[i][1][1]['template']])
        assert rule_entry_name not in database.kinetics.families[reaction_list[i].family].rules.entries
        print()

# #### Estimated using average of templates
#
# This means the combination of groups does not match a rule entry, and we had to use more generic groups on both subtrees. The data is an average of the more generic rules matched on each subtree.

for i in range(len(reaction_list)):
    if 'Estimated using average of templates' in reaction_list[i].kinetics.comment:
        print(i, reaction_list[i].kinetics.comment)
        print()

# #### Estimated using an average for rate rules
#
# This means that the original groups being queried exist as a rule on the tree, but that rule only has data because it averaged the results from other nodes. There are no training reactions matched most specifically to the given template.

for i in range(len(reaction_list)):
    if 'Estimated using an average for rate rule' in reaction_list[i].kinetics.comment:
        template_name = ';'.join([template.label for template in sources[i][1][1]['template']])
        for j in range(len(database.kinetics.families[reaction_list[i].family].rules.entries[template_name])):
            assert 'Average of' in database.kinetics.families[reaction_list[i].family].rules.entries[template_name][j].data.comment

        print(i, reaction_list[i].kinetics.comment)
        print()




